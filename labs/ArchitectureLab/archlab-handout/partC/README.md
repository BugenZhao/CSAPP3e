**参见 `../sim/pipe/ncopy.ys`**

## 要点

- 利用 **循环展开** 技术，将原始循环最高展开至 10 路，减少对 `%rdi`, `%rsi`, `%rdx ` 的访问。

- 采用 **Load forwarding** 技术时，`mrmovq `后接 `rmmovq `或 `pushq `指令时，无需触发 Stall。尽管如此，在不修改 Y86-64 `pipe-full` 实现的前提下，我们还是通过调整指令顺序，尽量避免load/use data hazard，提高流水线利用率。 具体在本例中，loop阶段在 `mrmovq` 和 `rmmovq` 之间预先加载 8 字节后的数据，利用两个寄存器轮流保存。

- 对于 10 路循环，可能出现 0 - 9 个元素的剩余，此时的方案有：

  - 继续使用循环；或将此循环展开，不断对计数器加一判断；
  - 倒序处理，根据剩余元素个数跳转到对应地址，向下依此处理直到处理完第一个元素。

  方案二可以带来更高的效率。考虑到 Y86-64 没有乘法、移位和间接跳转指令，我们建立一个三叉树，用最少的比较次数获得跳转地址。

- 剩余元素处理的细节：为避免 load/use hazard ，在 `mrmovq` 此元素之后，不直接操作这个元素，而是对上一个元素进行 `jle`，以决定计数器是否加 1。对于剩余元素不满 9 个、中途跳转进来的情况，我们采用一个从未使用的 `%r10` 作为 load 用的寄存器，它具有初值 0x0，这样即使中途跳转进来，0x0 同样满足 `jle` 条件，表现正常的行为。

- 细节中的细节：

  - 调整各块的顺序，避免任何不必要的 `jxx` 和 `ret` ，尽量让最后的 case 可以直接落入下方代码；
  - 交换分支语句，以尝试达到最佳表现；若修改 pipe 的分支预测实现可达到更好的效果。
  - 为追求性能，不惜删掉 `xorq %rax, %rax` 。

- `iaddq` 相当浪费空间。将 `$1` 提取出来后，在大幅节省空间的同时，这句 `irmovq` 也带来了严重的 CPE 损失。

## 结果

```bash
➜  pipe git:(master) ✗ ./benchmark.pl
...
Average CPE     7.54
Score   59.2/60.0

➜  pipe git:(master) ✗ ./check-len.pl < ncopy.yo
ncopy length = 988 bytes
```

